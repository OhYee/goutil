// Code generated by GCG. DO NOT EDIT.
// Go Code Generator 0.0.8 (https://github.com/OhYee/gcg)

package bytes

import (
	"github.com/OhYee/goutils"
	"testing"
)

func TestFromString(t *testing.T) {
	tests := []struct {
		name  string
		value string
		wantB []byte
	}{
		{
			name:  "test <no value> abc",
			value: "abc",
			wantB: []byte{97, 98, 99},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotB := FromString(tt.value); !goutils.Equal(gotB, tt.wantB) {
				t.Errorf("FromString() = %v, want %v", gotB, tt.wantB)
			}
		})
	}
}

func TestFromUint8(t *testing.T) {
	tests := []struct {
		name  string
		value uint8
		wantB []byte
	}{
		{
			name:  "test uint8 25",
			value: 25,
			wantB: []byte{0x19},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotB := FromUint8(tt.value); !goutils.Equal(gotB, tt.wantB) {
				t.Errorf("FromUint8() = %v, want %v", gotB, tt.wantB)
			}
		})
	}
}

func TestToUint8(t *testing.T) {
	tests := []struct {
		name string
		b    []byte
		want uint8
	}{
		{
			name: "test uint8 25",
			b:    []byte{0x19},
			want: 25,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := ToUint8(tt.b); !goutils.Equal(got, tt.want) {
				t.Errorf("ToUint8() = %v, want %v", got, tt.want)
			}
		})
	}
}
func TestFromUint16(t *testing.T) {
	tests := []struct {
		name  string
		value uint16
		wantB []byte
	}{
		{
			name:  "test uint16 25*25",
			value: 25 * 25,
			wantB: []byte{0x02, 0x71},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotB := FromUint16(tt.value); !goutils.Equal(gotB, tt.wantB) {
				t.Errorf("FromUint16() = %v, want %v", gotB, tt.wantB)
			}
		})
	}
}

func TestToUint16(t *testing.T) {
	tests := []struct {
		name string
		b    []byte
		want uint16
	}{
		{
			name: "test uint16 25*25",
			b:    []byte{0x02, 0x71},
			want: 25 * 25,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := ToUint16(tt.b); !goutils.Equal(got, tt.want) {
				t.Errorf("ToUint16() = %v, want %v", got, tt.want)
			}
		})
	}
}
func TestFromUint32(t *testing.T) {
	tests := []struct {
		name  string
		value uint32
		wantB []byte
	}{
		{
			name:  "test uint32 25*25*25*25",
			value: 25 * 25 * 25 * 25,
			wantB: []byte{0x00, 0x05, 0xf5, 0xe1},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotB := FromUint32(tt.value); !goutils.Equal(gotB, tt.wantB) {
				t.Errorf("FromUint32() = %v, want %v", gotB, tt.wantB)
			}
		})
	}
}

func TestToUint32(t *testing.T) {
	tests := []struct {
		name string
		b    []byte
		want uint32
	}{
		{
			name: "test uint32 25*25*25*25",
			b:    []byte{0x00, 0x05, 0xf5, 0xe1},
			want: 25 * 25 * 25 * 25,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := ToUint32(tt.b); !goutils.Equal(got, tt.want) {
				t.Errorf("ToUint32() = %v, want %v", got, tt.want)
			}
		})
	}
}
func TestFromUint64(t *testing.T) {
	tests := []struct {
		name  string
		value uint64
		wantB []byte
	}{
		{
			name:  "test uint64 25*25*25*25*25*25*25*25",
			value: 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25,
			wantB: []byte{0x00, 0x00, 0x00, 0x23, 0x86, 0xf2, 0x6f, 0xc1},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotB := FromUint64(tt.value); !goutils.Equal(gotB, tt.wantB) {
				t.Errorf("FromUint64() = %v, want %v", gotB, tt.wantB)
			}
		})
	}
}

func TestToUint64(t *testing.T) {
	tests := []struct {
		name string
		b    []byte
		want uint64
	}{
		{
			name: "test uint64 25*25*25*25*25*25*25*25",
			b:    []byte{0x00, 0x00, 0x00, 0x23, 0x86, 0xf2, 0x6f, 0xc1},
			want: 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := ToUint64(tt.b); !goutils.Equal(got, tt.want) {
				t.Errorf("ToUint64() = %v, want %v", got, tt.want)
			}
		})
	}
}
func TestFromInt8(t *testing.T) {
	tests := []struct {
		name  string
		value int8
		wantB []byte
	}{
		{
			name:  "test int8 25",
			value: 25,
			wantB: []byte{0x19},
		},

		{
			name:  "test int8 -25",
			value: -25,
			wantB: []byte{0xE7},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotB := FromInt8(tt.value); !goutils.Equal(gotB, tt.wantB) {
				t.Errorf("FromInt8() = %v, want %v", gotB, tt.wantB)
			}
		})
	}
}

func TestToInt8(t *testing.T) {
	tests := []struct {
		name string
		b    []byte
		want int8
	}{
		{
			name: "test int8 25",
			b:    []byte{0x19},
			want: 25,
		},

		{
			name: "test int8 -25",
			b:    []byte{0xE7},
			want: -25,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := ToInt8(tt.b); !goutils.Equal(got, tt.want) {
				t.Errorf("ToInt8() = %v, want %v", got, tt.want)
			}
		})
	}
}
func TestFromInt16(t *testing.T) {
	tests := []struct {
		name  string
		value int16
		wantB []byte
	}{
		{
			name:  "test int16 25*25",
			value: 25 * 25,
			wantB: []byte{0x02, 0x71},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotB := FromInt16(tt.value); !goutils.Equal(gotB, tt.wantB) {
				t.Errorf("FromInt16() = %v, want %v", gotB, tt.wantB)
			}
		})
	}
}

func TestToInt16(t *testing.T) {
	tests := []struct {
		name string
		b    []byte
		want int16
	}{
		{
			name: "test int16 25*25",
			b:    []byte{0x02, 0x71},
			want: 25 * 25,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := ToInt16(tt.b); !goutils.Equal(got, tt.want) {
				t.Errorf("ToInt16() = %v, want %v", got, tt.want)
			}
		})
	}
}
func TestFromInt32(t *testing.T) {
	tests := []struct {
		name  string
		value int32
		wantB []byte
	}{
		{
			name:  "test int32 25*25*25*25",
			value: 25 * 25 * 25 * 25,
			wantB: []byte{0x00, 0x05, 0xf5, 0xe1},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotB := FromInt32(tt.value); !goutils.Equal(gotB, tt.wantB) {
				t.Errorf("FromInt32() = %v, want %v", gotB, tt.wantB)
			}
		})
	}
}

func TestToInt32(t *testing.T) {
	tests := []struct {
		name string
		b    []byte
		want int32
	}{
		{
			name: "test int32 25*25*25*25",
			b:    []byte{0x00, 0x05, 0xf5, 0xe1},
			want: 25 * 25 * 25 * 25,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := ToInt32(tt.b); !goutils.Equal(got, tt.want) {
				t.Errorf("ToInt32() = %v, want %v", got, tt.want)
			}
		})
	}
}
func TestFromInt64(t *testing.T) {
	tests := []struct {
		name  string
		value int64
		wantB []byte
	}{
		{
			name:  "test int64 25*25*25*25*25*25*25*25",
			value: 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25,
			wantB: []byte{0x00, 0x00, 0x00, 0x23, 0x86, 0xf2, 0x6f, 0xc1},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotB := FromInt64(tt.value); !goutils.Equal(gotB, tt.wantB) {
				t.Errorf("FromInt64() = %v, want %v", gotB, tt.wantB)
			}
		})
	}
}

func TestToInt64(t *testing.T) {
	tests := []struct {
		name string
		b    []byte
		want int64
	}{
		{
			name: "test int64 25*25*25*25*25*25*25*25",
			b:    []byte{0x00, 0x00, 0x00, 0x23, 0x86, 0xf2, 0x6f, 0xc1},
			want: 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := ToInt64(tt.b); !goutils.Equal(got, tt.want) {
				t.Errorf("ToInt64() = %v, want %v", got, tt.want)
			}
		})
	}
}
func TestFromFloat32(t *testing.T) {
	tests := []struct {
		name  string
		value float32
		wantB []byte
	}{
		{
			name:  "test float32 1.0",
			value: 1.0,
			wantB: []byte{0x3f, 0x80, 0x00, 0x00},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotB := FromFloat32(tt.value); !goutils.Equal(gotB, tt.wantB) {
				t.Errorf("FromFloat32() = %v, want %v", gotB, tt.wantB)
			}
		})
	}
}

func TestToFloat32(t *testing.T) {
	tests := []struct {
		name string
		b    []byte
		want float32
	}{
		{
			name: "test float32 1.0",
			b:    []byte{0x3f, 0x80, 0x00, 0x00},
			want: 1.0,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := ToFloat32(tt.b); !goutils.Equal(got, tt.want) {
				t.Errorf("ToFloat32() = %v, want %v", got, tt.want)
			}
		})
	}
}
func TestFromFloat64(t *testing.T) {
	tests := []struct {
		name  string
		value float64
		wantB []byte
	}{
		{
			name:  "test float64 1.0",
			value: 1.0,
			wantB: []byte{0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotB := FromFloat64(tt.value); !goutils.Equal(gotB, tt.wantB) {
				t.Errorf("FromFloat64() = %v, want %v", gotB, tt.wantB)
			}
		})
	}
}

func TestToFloat64(t *testing.T) {
	tests := []struct {
		name string
		b    []byte
		want float64
	}{
		{
			name: "test float64 1.0",
			b:    []byte{0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			want: 1.0,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := ToFloat64(tt.b); !goutils.Equal(got, tt.want) {
				t.Errorf("ToFloat64() = %v, want %v", got, tt.want)
			}
		})
	}
}
