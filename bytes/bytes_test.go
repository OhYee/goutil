// Code generated by GCG. DO NOT EDIT.
// Go Code Generator 0.0.7 (https://github.com/OhYee/gcg)

package bytes

import (
	"github.com/OhYee/goutils"
	"testing"
)

func TestFromString(t *testing.T) {
	tests := []struct {
		name  string
		value string
		wantB []byte
	}{
		{
			name:  "test <no value> abc",
			value: "abc",
			wantB: []byte{97, 98, 99},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotB := FromString(tt.value); !goutils.Equal(gotB, tt.wantB) {
				t.Errorf("FromString() = %v, want %v", gotB, tt.wantB)
			}
		})
	}
}

func TestFromUint8(t *testing.T) {
	tests := []struct {
		name  string
		value uint8
		wantB []byte
	}{
		{
			name:  "test uint8 25",
			value: 25,
			wantB: []byte{0x19},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotB := FromUint8(tt.value); !goutils.Equal(gotB, tt.wantB) {
				t.Errorf("FromUint8() = %v, want %v", gotB, tt.wantB)
			}
		})
	}
}

func TestFromUint16(t *testing.T) {
	tests := []struct {
		name  string
		value uint16
		wantB []byte
	}{
		{
			name:  "test uint16 25*25",
			value: 25 * 25,
			wantB: []byte{0x02, 0x71},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotB := FromUint16(tt.value); !goutils.Equal(gotB, tt.wantB) {
				t.Errorf("FromUint16() = %v, want %v", gotB, tt.wantB)
			}
		})
	}
}

func TestFromUint32(t *testing.T) {
	tests := []struct {
		name  string
		value uint32
		wantB []byte
	}{
		{
			name:  "test uint32 25*25*25*25",
			value: 25 * 25 * 25 * 25,
			wantB: []byte{0x00, 0x05, 0xf5, 0xe1},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotB := FromUint32(tt.value); !goutils.Equal(gotB, tt.wantB) {
				t.Errorf("FromUint32() = %v, want %v", gotB, tt.wantB)
			}
		})
	}
}

func TestFromUint64(t *testing.T) {
	tests := []struct {
		name  string
		value uint64
		wantB []byte
	}{
		{
			name:  "test uint64 25*25*25*25*25*25*25*25",
			value: 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25,
			wantB: []byte{0x00, 0x00, 0x00, 0x23, 0x86, 0xf2, 0x6f, 0xc1},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotB := FromUint64(tt.value); !goutils.Equal(gotB, tt.wantB) {
				t.Errorf("FromUint64() = %v, want %v", gotB, tt.wantB)
			}
		})
	}
}

func TestFromInt8(t *testing.T) {
	tests := []struct {
		name  string
		value int8
		wantB []byte
	}{
		{
			name:  "test int8 25",
			value: 25,
			wantB: []byte{0x19},
		},

		{
			name:  "test int8 -25",
			value: -25,
			wantB: []byte{0xE7},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotB := FromInt8(tt.value); !goutils.Equal(gotB, tt.wantB) {
				t.Errorf("FromInt8() = %v, want %v", gotB, tt.wantB)
			}
		})
	}
}

func TestFromInt16(t *testing.T) {
	tests := []struct {
		name  string
		value int16
		wantB []byte
	}{
		{
			name:  "test int16 25*25",
			value: 25 * 25,
			wantB: []byte{0x02, 0x71},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotB := FromInt16(tt.value); !goutils.Equal(gotB, tt.wantB) {
				t.Errorf("FromInt16() = %v, want %v", gotB, tt.wantB)
			}
		})
	}
}

func TestFromInt32(t *testing.T) {
	tests := []struct {
		name  string
		value int32
		wantB []byte
	}{
		{
			name:  "test int32 25*25*25*25",
			value: 25 * 25 * 25 * 25,
			wantB: []byte{0x00, 0x05, 0xf5, 0xe1},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotB := FromInt32(tt.value); !goutils.Equal(gotB, tt.wantB) {
				t.Errorf("FromInt32() = %v, want %v", gotB, tt.wantB)
			}
		})
	}
}

func TestFromInt64(t *testing.T) {
	tests := []struct {
		name  string
		value int64
		wantB []byte
	}{
		{
			name:  "test int64 25*25*25*25*25*25*25*25",
			value: 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25,
			wantB: []byte{0x00, 0x00, 0x00, 0x23, 0x86, 0xf2, 0x6f, 0xc1},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotB := FromInt64(tt.value); !goutils.Equal(gotB, tt.wantB) {
				t.Errorf("FromInt64() = %v, want %v", gotB, tt.wantB)
			}
		})
	}
}

func TestFromFloat32(t *testing.T) {
	tests := []struct {
		name  string
		value float32
		wantB []byte
	}{
		{
			name:  "test float32 1.0",
			value: 1.0,
			wantB: []byte{0x3f, 0x80, 0x00, 0x00},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotB := FromFloat32(tt.value); !goutils.Equal(gotB, tt.wantB) {
				t.Errorf("FromFloat32() = %v, want %v", gotB, tt.wantB)
			}
		})
	}
}

func TestFromFloat64(t *testing.T) {
	tests := []struct {
		name  string
		value float64
		wantB []byte
	}{
		{
			name:  "test float64 1.0",
			value: 1.0,
			wantB: []byte{0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotB := FromFloat64(tt.value); !goutils.Equal(gotB, tt.wantB) {
				t.Errorf("FromFloat64() = %v, want %v", gotB, tt.wantB)
			}
		})
	}
}
