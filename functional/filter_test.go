// Code generated by GCG. DO NOT EDIT.
// Go Code Generator 0.0.8 (https://github.com/OhYee/gcg)

package fp

import (
	"reflect"
	"testing"
)

func TestFilterString(t *testing.T) {
	type args struct {
		f     func(string, int) bool
		input []string
	}
	tests := []struct {
		name       string
		args       args
		wantOutput []string
	}{
		{
			name:       "test all true",
			args:       args{f: func(s string, idx int) bool { return true }, input: []string{"a", "b", "C", "1"}},
			wantOutput: []string{"a", "b", "C", "1"},
		},
		{
			name:       "test len > 2",
			args:       args{f: func(s string, idx int) bool { return len(s) > 2 }, input: []string{"a", "b", "C", "1"}},
			wantOutput: []string{},
		},
		{
			name:       "test len > 1",
			args:       args{f: func(s string, idx int) bool { return len(s) > 1 }, input: []string{"ab", "bc", "Cd", "1"}},
			wantOutput: []string{"ab", "bc", "Cd"},
		},
		{
			name:       "test first rune is a",
			args:       args{f: func(s string, idx int) bool { return s[0] == 'a' }, input: []string{"ab", "bc", "Cd", "1"}},
			wantOutput: []string{"ab"},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := FilterString(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("FilterString() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestFilterInt(t *testing.T) {
	type args struct {
		f     func(int, int) bool
		input []int
	}
	tests := []struct {
		name       string
		args       args
		wantOutput []int
	}{
		{
			name:       "more than 3",
			args:       args{f: func(n int, idx int) bool { return n > 3 }, input: []int{1, 2, 3, 4, 5}},
			wantOutput: []int{4, 5},
		},
		{
			name:       "less than 2",
			args:       args{f: func(n int, idx int) bool { return n < 2 }, input: []int{1, 2, 3, 4, 5}},
			wantOutput: []int{1},
		},
		{
			name:       "even number",
			args:       args{f: func(n int, idx int) bool { return n%2 == 0 }, input: []int{1, 2, 3, 4, 5}},
			wantOutput: []int{2, 4},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := FilterInt(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("FilterInt() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestFilterInt8(t *testing.T) {
	type args struct {
		f     func(int8, int) bool
		input []int8
	}
	tests := []struct {
		name       string
		args       args
		wantOutput []int8
	}{
		{
			name:       "more than 3",
			args:       args{f: func(n int8, idx int) bool { return n > 3 }, input: []int8{1, 2, 3, 4, 5}},
			wantOutput: []int8{4, 5},
		},
		{
			name:       "less than 2",
			args:       args{f: func(n int8, idx int) bool { return n < 2 }, input: []int8{1, 2, 3, 4, 5}},
			wantOutput: []int8{1},
		},
		{
			name:       "even number",
			args:       args{f: func(n int8, idx int) bool { return n%2 == 0 }, input: []int8{1, 2, 3, 4, 5}},
			wantOutput: []int8{2, 4},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := FilterInt8(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("FilterInt8() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestFilterInt16(t *testing.T) {
	type args struct {
		f     func(int16, int) bool
		input []int16
	}
	tests := []struct {
		name       string
		args       args
		wantOutput []int16
	}{
		{
			name:       "more than 3",
			args:       args{f: func(n int16, idx int) bool { return n > 3 }, input: []int16{1, 2, 3, 4, 5}},
			wantOutput: []int16{4, 5},
		},
		{
			name:       "less than 2",
			args:       args{f: func(n int16, idx int) bool { return n < 2 }, input: []int16{1, 2, 3, 4, 5}},
			wantOutput: []int16{1},
		},
		{
			name:       "even number",
			args:       args{f: func(n int16, idx int) bool { return n%2 == 0 }, input: []int16{1, 2, 3, 4, 5}},
			wantOutput: []int16{2, 4},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := FilterInt16(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("FilterInt16() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestFilterInt32(t *testing.T) {
	type args struct {
		f     func(int32, int) bool
		input []int32
	}
	tests := []struct {
		name       string
		args       args
		wantOutput []int32
	}{
		{
			name:       "more than 3",
			args:       args{f: func(n int32, idx int) bool { return n > 3 }, input: []int32{1, 2, 3, 4, 5}},
			wantOutput: []int32{4, 5},
		},
		{
			name:       "less than 2",
			args:       args{f: func(n int32, idx int) bool { return n < 2 }, input: []int32{1, 2, 3, 4, 5}},
			wantOutput: []int32{1},
		},
		{
			name:       "even number",
			args:       args{f: func(n int32, idx int) bool { return n%2 == 0 }, input: []int32{1, 2, 3, 4, 5}},
			wantOutput: []int32{2, 4},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := FilterInt32(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("FilterInt32() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestFilterInt64(t *testing.T) {
	type args struct {
		f     func(int64, int) bool
		input []int64
	}
	tests := []struct {
		name       string
		args       args
		wantOutput []int64
	}{
		{
			name:       "more than 3",
			args:       args{f: func(n int64, idx int) bool { return n > 3 }, input: []int64{1, 2, 3, 4, 5}},
			wantOutput: []int64{4, 5},
		},
		{
			name:       "less than 2",
			args:       args{f: func(n int64, idx int) bool { return n < 2 }, input: []int64{1, 2, 3, 4, 5}},
			wantOutput: []int64{1},
		},
		{
			name:       "even number",
			args:       args{f: func(n int64, idx int) bool { return n%2 == 0 }, input: []int64{1, 2, 3, 4, 5}},
			wantOutput: []int64{2, 4},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := FilterInt64(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("FilterInt64() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestFilterUint8(t *testing.T) {
	type args struct {
		f     func(uint8, int) bool
		input []uint8
	}
	tests := []struct {
		name       string
		args       args
		wantOutput []uint8
	}{
		{
			name:       "more than 3",
			args:       args{f: func(n uint8, idx int) bool { return n > 3 }, input: []uint8{1, 2, 3, 4, 5}},
			wantOutput: []uint8{4, 5},
		},
		{
			name:       "less than 2",
			args:       args{f: func(n uint8, idx int) bool { return n < 2 }, input: []uint8{1, 2, 3, 4, 5}},
			wantOutput: []uint8{1},
		},
		{
			name:       "even number",
			args:       args{f: func(n uint8, idx int) bool { return n%2 == 0 }, input: []uint8{1, 2, 3, 4, 5}},
			wantOutput: []uint8{2, 4},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := FilterUint8(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("FilterUint8() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestFilterUint16(t *testing.T) {
	type args struct {
		f     func(uint16, int) bool
		input []uint16
	}
	tests := []struct {
		name       string
		args       args
		wantOutput []uint16
	}{
		{
			name:       "more than 3",
			args:       args{f: func(n uint16, idx int) bool { return n > 3 }, input: []uint16{1, 2, 3, 4, 5}},
			wantOutput: []uint16{4, 5},
		},
		{
			name:       "less than 2",
			args:       args{f: func(n uint16, idx int) bool { return n < 2 }, input: []uint16{1, 2, 3, 4, 5}},
			wantOutput: []uint16{1},
		},
		{
			name:       "even number",
			args:       args{f: func(n uint16, idx int) bool { return n%2 == 0 }, input: []uint16{1, 2, 3, 4, 5}},
			wantOutput: []uint16{2, 4},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := FilterUint16(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("FilterUint16() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestFilterUint32(t *testing.T) {
	type args struct {
		f     func(uint32, int) bool
		input []uint32
	}
	tests := []struct {
		name       string
		args       args
		wantOutput []uint32
	}{
		{
			name:       "more than 3",
			args:       args{f: func(n uint32, idx int) bool { return n > 3 }, input: []uint32{1, 2, 3, 4, 5}},
			wantOutput: []uint32{4, 5},
		},
		{
			name:       "less than 2",
			args:       args{f: func(n uint32, idx int) bool { return n < 2 }, input: []uint32{1, 2, 3, 4, 5}},
			wantOutput: []uint32{1},
		},
		{
			name:       "even number",
			args:       args{f: func(n uint32, idx int) bool { return n%2 == 0 }, input: []uint32{1, 2, 3, 4, 5}},
			wantOutput: []uint32{2, 4},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := FilterUint32(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("FilterUint32() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestFilterUint64(t *testing.T) {
	type args struct {
		f     func(uint64, int) bool
		input []uint64
	}
	tests := []struct {
		name       string
		args       args
		wantOutput []uint64
	}{
		{
			name:       "more than 3",
			args:       args{f: func(n uint64, idx int) bool { return n > 3 }, input: []uint64{1, 2, 3, 4, 5}},
			wantOutput: []uint64{4, 5},
		},
		{
			name:       "less than 2",
			args:       args{f: func(n uint64, idx int) bool { return n < 2 }, input: []uint64{1, 2, 3, 4, 5}},
			wantOutput: []uint64{1},
		},
		{
			name:       "even number",
			args:       args{f: func(n uint64, idx int) bool { return n%2 == 0 }, input: []uint64{1, 2, 3, 4, 5}},
			wantOutput: []uint64{2, 4},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := FilterUint64(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("FilterUint64() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestFilterFloat32(t *testing.T) {
	type args struct {
		f     func(float32, int) bool
		input []float32
	}
	tests := []struct {
		name       string
		args       args
		wantOutput []float32
	}{
		{
			name:       "more than 3",
			args:       args{f: func(n float32, idx int) bool { return n > 3 }, input: []float32{1, 2, 3, 4, 5}},
			wantOutput: []float32{4, 5},
		},
		{
			name:       "less than 2",
			args:       args{f: func(n float32, idx int) bool { return n < 2 }, input: []float32{1, 2, 3, 4, 5}},
			wantOutput: []float32{1},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := FilterFloat32(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("FilterFloat32() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestFilterFloat64(t *testing.T) {
	type args struct {
		f     func(float64, int) bool
		input []float64
	}
	tests := []struct {
		name       string
		args       args
		wantOutput []float64
	}{
		{
			name:       "more than 3",
			args:       args{f: func(n float64, idx int) bool { return n > 3 }, input: []float64{1, 2, 3, 4, 5}},
			wantOutput: []float64{4, 5},
		},
		{
			name:       "less than 2",
			args:       args{f: func(n float64, idx int) bool { return n < 2 }, input: []float64{1, 2, 3, 4, 5}},
			wantOutput: []float64{1},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := FilterFloat64(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("FilterFloat64() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestFilterByte(t *testing.T) {
	type args struct {
		f     func(byte, int) bool
		input []byte
	}
	tests := []struct {
		name       string
		args       args
		wantOutput []byte
	}{
		{
			name:       "more than 3",
			args:       args{f: func(n byte, idx int) bool { return n > 3 }, input: []byte{1, 2, 3, 4, 5}},
			wantOutput: []byte{4, 5},
		},
		{
			name:       "less than 2",
			args:       args{f: func(n byte, idx int) bool { return n < 2 }, input: []byte{1, 2, 3, 4, 5}},
			wantOutput: []byte{1},
		},
		{
			name:       "even number",
			args:       args{f: func(n byte, idx int) bool { return n%2 == 0 }, input: []byte{1, 2, 3, 4, 5}},
			wantOutput: []byte{2, 4},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := FilterByte(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("FilterByte() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestFilter(t *testing.T) {
	type args struct {
		f     func(any, int) bool
		input []any
	}
	tests := []struct {
		name       string
		args       args
		wantOutput []any
	}{
		{
			name:       "is int",
			args:       args{f: func(s any, idx int) bool { return reflect.TypeOf(s).Kind() == reflect.Int }, input: []any{1, "A", 2, "c"}},
			wantOutput: []any{1, 2},
		},
		{
			name:       "is string",
			args:       args{f: func(s any, idx int) bool { return reflect.TypeOf(s).Kind() == reflect.String }, input: []any{1, "A", 2, "c"}},
			wantOutput: []any{"A", "c"},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := Filter(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("Filter() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}
