// Code generated by GCG. DO NOT EDIT.
// Go Code Generator 0.0.7 (https://github.com/OhYee/gcg)

package fp

import (
	"reflect"
	"testing"
)

func TestAllString(t *testing.T) {
	type args struct {
		f     func(string) bool
		input []string
	}
	tests := []struct {
		name       string
		args       args
		wantOutput bool
	}{
		{
			name:       "all item is true",
			args:       args{f: func(s string) bool { return len(s) > 0 }, input: []string{"a", "bb", "ccc", "dddd"}},
			wantOutput: true,
		},
		{
			name:       "some items are true and others are false",
			args:       args{f: func(s string) bool { return len(s) > 2 }, input: []string{"a", "bb", "ccc", "dddd"}},
			wantOutput: false,
		},
		{
			name:       "all item is false",
			args:       args{f: func(s string) bool { return len(s) > 5 }, input: []string{"a", "bb", "ccc", "dddd"}},
			wantOutput: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := AllString(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("AllString() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestAllInt(t *testing.T) {
	type args struct {
		f     func(int) bool
		input []int
	}
	tests := []struct {
		name       string
		args       args
		wantOutput bool
	}{
		{
			name:       "all item is true",
			args:       args{f: func(n int) bool { return n > 0 }, input: []int{1, 2, 3, 4, 5}},
			wantOutput: true,
		},
		{
			name:       "some items are true and others are false",
			args:       args{f: func(n int) bool { return n > 3 }, input: []int{1, 2, 3, 4, 5}},
			wantOutput: false,
		},
		{
			name:       "all item is false",
			args:       args{f: func(n int) bool { return n > 5 }, input: []int{1, 2, 3, 4, 5}},
			wantOutput: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := AllInt(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("AllInt() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestAllInt8(t *testing.T) {
	type args struct {
		f     func(int8) bool
		input []int8
	}
	tests := []struct {
		name       string
		args       args
		wantOutput bool
	}{
		{
			name:       "all item is true",
			args:       args{f: func(n int8) bool { return n > 0 }, input: []int8{1, 2, 3, 4, 5}},
			wantOutput: true,
		},
		{
			name:       "some items are true and others are false",
			args:       args{f: func(n int8) bool { return n > 3 }, input: []int8{1, 2, 3, 4, 5}},
			wantOutput: false,
		},
		{
			name:       "all item is false",
			args:       args{f: func(n int8) bool { return n > 5 }, input: []int8{1, 2, 3, 4, 5}},
			wantOutput: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := AllInt8(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("AllInt8() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestAllInt16(t *testing.T) {
	type args struct {
		f     func(int16) bool
		input []int16
	}
	tests := []struct {
		name       string
		args       args
		wantOutput bool
	}{
		{
			name:       "all item is true",
			args:       args{f: func(n int16) bool { return n > 0 }, input: []int16{1, 2, 3, 4, 5}},
			wantOutput: true,
		},
		{
			name:       "some items are true and others are false",
			args:       args{f: func(n int16) bool { return n > 3 }, input: []int16{1, 2, 3, 4, 5}},
			wantOutput: false,
		},
		{
			name:       "all item is false",
			args:       args{f: func(n int16) bool { return n > 5 }, input: []int16{1, 2, 3, 4, 5}},
			wantOutput: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := AllInt16(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("AllInt16() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestAllInt32(t *testing.T) {
	type args struct {
		f     func(int32) bool
		input []int32
	}
	tests := []struct {
		name       string
		args       args
		wantOutput bool
	}{
		{
			name:       "all item is true",
			args:       args{f: func(n int32) bool { return n > 0 }, input: []int32{1, 2, 3, 4, 5}},
			wantOutput: true,
		},
		{
			name:       "some items are true and others are false",
			args:       args{f: func(n int32) bool { return n > 3 }, input: []int32{1, 2, 3, 4, 5}},
			wantOutput: false,
		},
		{
			name:       "all item is false",
			args:       args{f: func(n int32) bool { return n > 5 }, input: []int32{1, 2, 3, 4, 5}},
			wantOutput: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := AllInt32(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("AllInt32() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestAllInt64(t *testing.T) {
	type args struct {
		f     func(int64) bool
		input []int64
	}
	tests := []struct {
		name       string
		args       args
		wantOutput bool
	}{
		{
			name:       "all item is true",
			args:       args{f: func(n int64) bool { return n > 0 }, input: []int64{1, 2, 3, 4, 5}},
			wantOutput: true,
		},
		{
			name:       "some items are true and others are false",
			args:       args{f: func(n int64) bool { return n > 3 }, input: []int64{1, 2, 3, 4, 5}},
			wantOutput: false,
		},
		{
			name:       "all item is false",
			args:       args{f: func(n int64) bool { return n > 5 }, input: []int64{1, 2, 3, 4, 5}},
			wantOutput: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := AllInt64(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("AllInt64() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestAllUint8(t *testing.T) {
	type args struct {
		f     func(uint8) bool
		input []uint8
	}
	tests := []struct {
		name       string
		args       args
		wantOutput bool
	}{
		{
			name:       "all item is true",
			args:       args{f: func(n uint8) bool { return n > 0 }, input: []uint8{1, 2, 3, 4, 5}},
			wantOutput: true,
		},
		{
			name:       "some items are true and others are false",
			args:       args{f: func(n uint8) bool { return n > 3 }, input: []uint8{1, 2, 3, 4, 5}},
			wantOutput: false,
		},
		{
			name:       "all item is false",
			args:       args{f: func(n uint8) bool { return n > 5 }, input: []uint8{1, 2, 3, 4, 5}},
			wantOutput: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := AllUint8(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("AllUint8() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestAllUint16(t *testing.T) {
	type args struct {
		f     func(uint16) bool
		input []uint16
	}
	tests := []struct {
		name       string
		args       args
		wantOutput bool
	}{
		{
			name:       "all item is true",
			args:       args{f: func(n uint16) bool { return n > 0 }, input: []uint16{1, 2, 3, 4, 5}},
			wantOutput: true,
		},
		{
			name:       "some items are true and others are false",
			args:       args{f: func(n uint16) bool { return n > 3 }, input: []uint16{1, 2, 3, 4, 5}},
			wantOutput: false,
		},
		{
			name:       "all item is false",
			args:       args{f: func(n uint16) bool { return n > 5 }, input: []uint16{1, 2, 3, 4, 5}},
			wantOutput: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := AllUint16(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("AllUint16() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestAllUint32(t *testing.T) {
	type args struct {
		f     func(uint32) bool
		input []uint32
	}
	tests := []struct {
		name       string
		args       args
		wantOutput bool
	}{
		{
			name:       "all item is true",
			args:       args{f: func(n uint32) bool { return n > 0 }, input: []uint32{1, 2, 3, 4, 5}},
			wantOutput: true,
		},
		{
			name:       "some items are true and others are false",
			args:       args{f: func(n uint32) bool { return n > 3 }, input: []uint32{1, 2, 3, 4, 5}},
			wantOutput: false,
		},
		{
			name:       "all item is false",
			args:       args{f: func(n uint32) bool { return n > 5 }, input: []uint32{1, 2, 3, 4, 5}},
			wantOutput: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := AllUint32(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("AllUint32() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestAllUint64(t *testing.T) {
	type args struct {
		f     func(uint64) bool
		input []uint64
	}
	tests := []struct {
		name       string
		args       args
		wantOutput bool
	}{
		{
			name:       "all item is true",
			args:       args{f: func(n uint64) bool { return n > 0 }, input: []uint64{1, 2, 3, 4, 5}},
			wantOutput: true,
		},
		{
			name:       "some items are true and others are false",
			args:       args{f: func(n uint64) bool { return n > 3 }, input: []uint64{1, 2, 3, 4, 5}},
			wantOutput: false,
		},
		{
			name:       "all item is false",
			args:       args{f: func(n uint64) bool { return n > 5 }, input: []uint64{1, 2, 3, 4, 5}},
			wantOutput: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := AllUint64(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("AllUint64() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestAllFloat32(t *testing.T) {
	type args struct {
		f     func(float32) bool
		input []float32
	}
	tests := []struct {
		name       string
		args       args
		wantOutput bool
	}{
		{
			name:       "all item is true",
			args:       args{f: func(n float32) bool { return n > 0 }, input: []float32{1, 2, 3, 4, 5}},
			wantOutput: true,
		},
		{
			name:       "some items are true and others are false",
			args:       args{f: func(n float32) bool { return n > 3 }, input: []float32{1, 2, 3, 4, 5}},
			wantOutput: false,
		},
		{
			name:       "all item is false",
			args:       args{f: func(n float32) bool { return n > 5 }, input: []float32{1, 2, 3, 4, 5}},
			wantOutput: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := AllFloat32(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("AllFloat32() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestAllFloat64(t *testing.T) {
	type args struct {
		f     func(float64) bool
		input []float64
	}
	tests := []struct {
		name       string
		args       args
		wantOutput bool
	}{
		{
			name:       "all item is true",
			args:       args{f: func(n float64) bool { return n > 0 }, input: []float64{1, 2, 3, 4, 5}},
			wantOutput: true,
		},
		{
			name:       "some items are true and others are false",
			args:       args{f: func(n float64) bool { return n > 3 }, input: []float64{1, 2, 3, 4, 5}},
			wantOutput: false,
		},
		{
			name:       "all item is false",
			args:       args{f: func(n float64) bool { return n > 5 }, input: []float64{1, 2, 3, 4, 5}},
			wantOutput: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := AllFloat64(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("AllFloat64() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestAllByte(t *testing.T) {
	type args struct {
		f     func(byte) bool
		input []byte
	}
	tests := []struct {
		name       string
		args       args
		wantOutput bool
	}{
		{
			name:       "all item is true",
			args:       args{f: func(n byte) bool { return n > 0 }, input: []byte{1, 2, 3, 4, 5}},
			wantOutput: true,
		},
		{
			name:       "some items are true and others are false",
			args:       args{f: func(n byte) bool { return n > 3 }, input: []byte{1, 2, 3, 4, 5}},
			wantOutput: false,
		},
		{
			name:       "all item is false",
			args:       args{f: func(n byte) bool { return n > 5 }, input: []byte{1, 2, 3, 4, 5}},
			wantOutput: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := AllByte(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("AllByte() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestAll(t *testing.T) {
	type args struct {
		f     func(any) bool
		input []any
	}
	tests := []struct {
		name       string
		args       args
		wantOutput bool
	}{
		{
			name:       "all item is true",
			args:       args{f: func(s any) bool { return reflect.TypeOf(s).Kind() == reflect.Int }, input: []any{1, 2}},
			wantOutput: true,
		},
		{
			name:       "some items are true and others are false",
			args:       args{f: func(s any) bool { return reflect.TypeOf(s).Kind() == reflect.Int }, input: []any{1, 2, "A"}},
			wantOutput: false,
		},
		{
			name:       "all item is false",
			args:       args{f: func(s any) bool { return reflect.TypeOf(s).Kind() == reflect.Int }, input: []any{"A", "B"}},
			wantOutput: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := All(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("All() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}
