// Code generated by GCG. DO NOT EDIT.
// Go Code Generator 0.0.8 (https://github.com/OhYee/gcg)

package fp

import (
	"fmt"
	"reflect"
	"testing"
)

func TestReduceString(t *testing.T) {
	type args struct {
		f     func(string, string) string
		input []string
	}
	tests := []struct {
		name       string
		args       args
		wantOutput string
	}{
		{
			name:       "concat string",
			args:       args{f: func(a string, b string) string { return a + b }, input: []string{"a", "bb", "ccc", "dddd"}},
			wantOutput: "abbcccdddd",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := ReduceString(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("ReduceString() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestReduceInt(t *testing.T) {
	type args struct {
		f     func(int, int) int
		input []int
	}
	tests := []struct {
		name       string
		args       args
		wantOutput int
	}{
		{
			name:       "sum",
			args:       args{f: func(a int, b int) int { return a + b }, input: []int{1, 2, 3, 4}},
			wantOutput: 10,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := ReduceInt(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("ReduceInt() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestReduceInt8(t *testing.T) {
	type args struct {
		f     func(int8, int8) int8
		input []int8
	}
	tests := []struct {
		name       string
		args       args
		wantOutput int8
	}{
		{
			name:       "sum",
			args:       args{f: func(a int8, b int8) int8 { return a + b }, input: []int8{1, 2, 3, 4}},
			wantOutput: 10,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := ReduceInt8(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("ReduceInt8() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestReduceInt16(t *testing.T) {
	type args struct {
		f     func(int16, int16) int16
		input []int16
	}
	tests := []struct {
		name       string
		args       args
		wantOutput int16
	}{
		{
			name:       "sum",
			args:       args{f: func(a int16, b int16) int16 { return a + b }, input: []int16{1, 2, 3, 4}},
			wantOutput: 10,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := ReduceInt16(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("ReduceInt16() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestReduceInt32(t *testing.T) {
	type args struct {
		f     func(int32, int32) int32
		input []int32
	}
	tests := []struct {
		name       string
		args       args
		wantOutput int32
	}{
		{
			name:       "sum",
			args:       args{f: func(a int32, b int32) int32 { return a + b }, input: []int32{1, 2, 3, 4}},
			wantOutput: 10,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := ReduceInt32(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("ReduceInt32() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestReduceInt64(t *testing.T) {
	type args struct {
		f     func(int64, int64) int64
		input []int64
	}
	tests := []struct {
		name       string
		args       args
		wantOutput int64
	}{
		{
			name:       "sum",
			args:       args{f: func(a int64, b int64) int64 { return a + b }, input: []int64{1, 2, 3, 4}},
			wantOutput: 10,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := ReduceInt64(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("ReduceInt64() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestReduceUint8(t *testing.T) {
	type args struct {
		f     func(uint8, uint8) uint8
		input []uint8
	}
	tests := []struct {
		name       string
		args       args
		wantOutput uint8
	}{
		{
			name:       "sum",
			args:       args{f: func(a uint8, b uint8) uint8 { return a + b }, input: []uint8{1, 2, 3, 4}},
			wantOutput: 10,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := ReduceUint8(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("ReduceUint8() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestReduceUint16(t *testing.T) {
	type args struct {
		f     func(uint16, uint16) uint16
		input []uint16
	}
	tests := []struct {
		name       string
		args       args
		wantOutput uint16
	}{
		{
			name:       "sum",
			args:       args{f: func(a uint16, b uint16) uint16 { return a + b }, input: []uint16{1, 2, 3, 4}},
			wantOutput: 10,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := ReduceUint16(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("ReduceUint16() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestReduceUint32(t *testing.T) {
	type args struct {
		f     func(uint32, uint32) uint32
		input []uint32
	}
	tests := []struct {
		name       string
		args       args
		wantOutput uint32
	}{
		{
			name:       "sum",
			args:       args{f: func(a uint32, b uint32) uint32 { return a + b }, input: []uint32{1, 2, 3, 4}},
			wantOutput: 10,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := ReduceUint32(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("ReduceUint32() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestReduceUint64(t *testing.T) {
	type args struct {
		f     func(uint64, uint64) uint64
		input []uint64
	}
	tests := []struct {
		name       string
		args       args
		wantOutput uint64
	}{
		{
			name:       "sum",
			args:       args{f: func(a uint64, b uint64) uint64 { return a + b }, input: []uint64{1, 2, 3, 4}},
			wantOutput: 10,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := ReduceUint64(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("ReduceUint64() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestReduceFloat32(t *testing.T) {
	type args struct {
		f     func(float32, float32) float32
		input []float32
	}
	tests := []struct {
		name       string
		args       args
		wantOutput float32
	}{
		{
			name:       "sum",
			args:       args{f: func(a float32, b float32) float32 { return a + b }, input: []float32{1, 2, 3, 4}},
			wantOutput: 10,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := ReduceFloat32(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("ReduceFloat32() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestReduceFloat64(t *testing.T) {
	type args struct {
		f     func(float64, float64) float64
		input []float64
	}
	tests := []struct {
		name       string
		args       args
		wantOutput float64
	}{
		{
			name:       "sum",
			args:       args{f: func(a float64, b float64) float64 { return a + b }, input: []float64{1, 2, 3, 4}},
			wantOutput: 10,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := ReduceFloat64(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("ReduceFloat64() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestReduceByte(t *testing.T) {
	type args struct {
		f     func(byte, byte) byte
		input []byte
	}
	tests := []struct {
		name       string
		args       args
		wantOutput byte
	}{
		{
			name:       "sum",
			args:       args{f: func(a byte, b byte) byte { return a + b }, input: []byte{1, 2, 3, 4}},
			wantOutput: 10,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := ReduceByte(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("ReduceByte() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}

func TestReduce(t *testing.T) {
	type args struct {
		f     func(any, any) any
		input []any
	}
	tests := []struct {
		name       string
		args       args
		wantOutput any
	}{
		{
			name:       "output as string",
			args:       args{f: func(a any, b any) any { return fmt.Sprint(a) + fmt.Sprint(b) }, input: []any{"a", "bb", 3, 4}},
			wantOutput: "<nil>abb34",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotOutput := Reduce(tt.args.f, tt.args.input); !reflect.DeepEqual(gotOutput, tt.wantOutput) {
				t.Errorf("Reduce() = %v, want %v", gotOutput, tt.wantOutput)
			}
		})
	}
}
